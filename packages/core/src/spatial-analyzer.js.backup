import * as turf from '@turf/turf';
import PlanningDataAPI from './planning-data-api.js';

export default class SpatialAnalyzer {
  constructor() {
    this.constraintLayers = new Map();
    this.analysisCache = new Map();
    this.googleMapsApiKey = null;
    this.planningDataAPI = new PlanningDataAPI();
    this.workers = new Map(); // Web Workers for heavy computation
    this.datasetCategories = {}; // Initialize to prevent undefined errors
    this.initialized = false;
    this.useWebWorkers = typeof Worker !== 'undefined'; // Check if Web Workers are available
    this.workerPool = [];
    this.maxWorkers = 4;
  }

  /**
   * Initialize worker pool for parallel processing
   */
  async initializeWorkerPool() {
    if (!this.useWebWorkers) {
      console.log('Web Workers not available, using main thread processing');
      return;
    }

    try {
      for (let i = 0; i < this.maxWorkers; i++) {
        const worker = new Worker(new URL('./spatial-worker.js', import.meta.url), {
          type: 'module'
        });
        this.workerPool.push({
          worker,
          busy: false,
          id: i
        });
      }
      console.log(`Initialized ${this.maxWorkers} spatial analysis workers`);
    } catch (error) {
      console.warn('Failed to initialize workers, falling back to main thread:', error);
      this.useWebWorkers = false;
    }
  }

  /**
   * Get an available worker from the pool
   */
  getAvailableWorker() {
    if (!this.useWebWorkers) return null;
    return this.workerPool.find(w => !w.busy);
  }

  /**
   * Execute operation in web worker with fallback to main thread
   */
  async executeInWorker(operation, data, timeout = 30000) {
    const worker = this.getAvailableWorker();
    
    if (!worker) {
      // Fallback to main thread
      return this.executeOnMainThread(operation, data);
    }

    return new Promise((resolve, reject) => {
      const id = Date.now() + Math.random();
      worker.busy = true;

      const timeoutId = setTimeout(() => {
        worker.busy = false;
        reject(new Error(`Worker operation ${operation} timed out`));
      }, timeout);

      const handleMessage = (e) => {
        if (e.data.id === id) {
          worker.worker.removeEventListener('message', handleMessage);
          worker.busy = false;
          clearTimeout(timeoutId);
          
          if (e.data.success) {
            resolve(e.data.result);
          } else {
            reject(new Error(e.data.error));
          }
        }
      };

      worker.worker.addEventListener('message', handleMessage);
      worker.worker.postMessage({ id, operation, data });
    });
  }

  /**
   * Fallback execution on main thread
   */
  async executeOnMainThread(operation, data) {
    switch (operation) {
      case 'calculateSiteMetrics':
        return this.calculateSiteMetrics(data.geometry);
      case 'batchIntersectionAnalysis':
        return this.processBatchIntersections(data.siteGeometry, data.constraints);
      case 'batchProximityAnalysis':
        return this.processBatchProximities(data.siteCenter, data.features, data.maxDistance);
      default:
        throw new Error(`Unknown operation: ${operation}`);
    }
  }

  /**
   * Process batch intersections on main thread (fallback)
   */
  processBatchIntersections(siteGeometry, constraints) {
    return constraints.map(constraint => {
      const intersection = this.calculateIntersection(siteGeometry, constraint.geometry);
      const coverage = intersection ? this.calculateCoverage(siteGeometry, intersection) : 0;
      
      return {
        ...constraint,
        intersection,
        coverage,
        impactLevel: this.assessConstraintImpact(constraint, coverage)
      };
    });
  }

  /**
   * Process batch proximities on main thread (fallback)
   */
  processBatchProximities(siteCenter, features, maxDistance = 2000) {
    return features.map(feature => {
      const distance = this.calculateDistanceToFeature(siteCenter, feature);
      return {
        ...feature,
        distance: Math.round(distance),
        accessibility_score: this.calculateAccessibilityScore(distance, maxDistance)
      };
    }).filter(f => f.distance <= maxDistance)
      .sort((a, b) => a.distance - b.distance);
  }

  setGoogleMapsApiKey(apiKey) {
    this.googleMapsApiKey = apiKey;
  }

  async initializeConstraintLayers() {
    // Initialize worker pool first
    await this.initializeWorkerPool();

    // Initialize with planning.data.gov.uk datasets
    const planningDataLayers = {
      // Heritage constraints (high priority)
      'conservation-area': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'conservation-area',
        description: 'Special architectural or historic interest'
      },
      'listed-building': { 
        type: 'point', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'listed-building',
        description: 'Buildings of special architectural or historic interest'
      },
      'listed-building-outline': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'listed-building-outline',
        description: 'Boundary of listed buildings'
      },
      'scheduled-monument': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'scheduled-monument',
        description: 'Historic sites of national importance'
      },
      'park-and-garden': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'park-and-garden',
        description: 'Historic parks and gardens'
      },
      'world-heritage-site': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'world-heritage-site',
        description: 'UNESCO World Heritage Sites'
      },
      'world-heritage-site-buffer-zone': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'world-heritage-site-buffer-zone',
        description: 'Buffer zones around World Heritage Sites'
      },
      'battlefield': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'battlefield',
        description: 'Historic battlefields'
      },
      'heritage-at-risk': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'heritage-at-risk',
        description: 'Heritage assets at risk'
      },
      'protected-wreck-site': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'protected-wreck-site',
        description: 'Protected wreck sites'
      },
      'locally-listed-building': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'locally-listed-building',
        description: 'Locally listed heritage assets'
      },
      'archaeological-priority-area': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'archaeological-priority-area',
        description: 'Areas of archaeological significance'
      },

      // Environmental constraints (high priority)
      'flood-risk-zone': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'flood-risk-zone',
        description: 'Areas at risk of flooding'
      },
      'area-of-outstanding-natural-beauty': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'area-of-outstanding-natural-beauty',
        description: 'Protected landscapes'
      },
      'site-of-special-scientific-interest': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'site-of-special-scientific-interest',
        description: 'Nationally protected wildlife/geological sites'
      },
      'special-area-of-conservation': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'special-area-of-conservation',
        description: 'EU designated conservation areas'
      },
      'special-protection-area': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'special-protection-area',
        description: 'Bird protection areas'
      },
      'ramsar': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'ramsar',
        description: 'Wetlands of international importance'
      },
      'ancient-woodland': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'ancient-woodland',
        description: 'Ancient woodland areas'
      },
      'green-belt': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'green-belt',
        description: 'Green belt land'
      },
      'tree-preservation-zone': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'tree-preservation-zone',
        description: 'Tree preservation order zones'
      },
      'tree': { 
        type: 'point', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'tree',
        description: 'Individual protected trees'
      },
      'national-nature-reserve': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'national-nature-reserve',
        description: 'National nature reserves'
      },
      'local-nature-reserve': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'local-nature-reserve',
        description: 'Local nature reserves'
      },
      'air-quality-management-area': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'air-quality-management-area',
        description: 'Air quality management areas'
      },
      'agricultural-land-classification': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'agricultural-land-classification',
        description: 'Agricultural land quality'
      },
      'flood-storage-area': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'flood-storage-area',
        description: 'Flood storage areas'
      },
      'heritage-coast': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'heritage-coast',
        description: 'Heritage coast areas'
      },
      'nature-improvement-area': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'nature-improvement-area',
        description: 'Nature improvement areas'
      },

      // Development constraints
      'article-4-direction-area': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'article-4-direction-area',
        description: 'Areas with restricted permitted development rights'
      },
      'brownfield-land': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'brownfield-land',
        description: 'Previously developed land'
      },
      'brownfield-site': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'brownfield-site',
        description: 'Brownfield site boundaries'
      },
      'central-activities-zone': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'central-activities-zone',
        description: 'Central London activity zone'
      },
      'building-preservation-notice': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'high',
        dataset: 'building-preservation-notice',
        description: 'Buildings with preservation notices'
      },
      'certificate-of-immunity': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'certificate-of-immunity',
        description: 'Buildings with immunity certificates'
      },

      // Administrative areas
      'local-planning-authority': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'local-planning-authority',
        description: 'Local planning authority boundaries'
      },
      'local-authority-district': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'local-authority-district',
        description: 'Local authority districts'
      },
      'parish': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'parish',
        description: 'Civil parishes'
      },
      'ward': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'ward',
        description: 'Electoral wards'
      },
      'national-park': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'national-park',
        description: 'National park boundaries'
      },

      // Transport and accessibility
      'transport-access-node': { 
        type: 'point', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'transport-access-node',
        description: 'Public transport access points'
      },

      // Infrastructure and utilities
      'infrastructure-project': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'infrastructure-project',
        description: 'Major infrastructure projects'
      },

      // Additional datasets for comprehensive coverage
      'educational-establishment': { 
        type: 'point', 
        source: 'planning_data_api', 
        priority: 'medium',
        dataset: 'educational-establishment',
        description: 'Schools and educational facilities'
      },
      'built-up-area': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'built-up-area',
        description: 'Built-up areas'
      },
      'title-boundary': { 
        type: 'polygon', 
        source: 'planning_data_api', 
        priority: 'low',
        dataset: 'title-boundary',
        description: 'Land registry boundaries'
      }
    };

    // Datasets that need to be derived from other sources
    const derivedLayers = {
      // Derive from transport-access-node with filtering
      'railway-station': {
        type: 'point',
        source: 'derived',
        priority: 'high',
        deriveFrom: 'transport-access-node',
        filter: (feature) => this.isRailwayStation(feature),
        description: 'Railway stations'
      },
      'bus-stop': {
        type: 'point',
        source: 'derived',
        priority: 'low',
        deriveFrom: 'transport-access-node',
        filter: (feature) => this.isBusStop(feature),
        description: 'Bus stops'
      },
      
      // Derive from educational-establishment with filtering
      'primary-school': {
        type: 'point',
        source: 'derived',
        priority: 'medium',
        deriveFrom: 'educational-establishment',
        filter: (feature) => this.isPrimarySchool(feature),
        description: 'Primary schools'
      },
      'secondary-school': {
        type: 'point',
        source: 'derived',
        priority: 'medium',
        deriveFrom: 'educational-establishment',
        filter: (feature) => this.isSecondarySchool(feature),
        description: 'Secondary schools'
      },

      // Best and most versatile agricultural land - derive from agricultural-land-classification
      'best-and-most-versatile-agricultural-land': {
        type: 'polygon',
        source: 'derived',
        priority: 'medium',
        deriveFrom: 'agricultural-land-classification',
        filter: (feature) => this.isBestAndMostVersatileAgriculturalLand(feature),
        description: 'Best and most versatile agricultural land (grades 1, 2, 3a)'
      }
    };

    // Initialize all layers
    for (const [name, config] of Object.entries({ ...planningDataLayers, ...derivedLayers })) {
      this.constraintLayers.set(name, {
        ...config,
        features: [],
        lastUpdated: null,
        enabled: true // Allow selective enabling/disabling
      });
    }

    // Define dataset categories for intelligent querying
    this.datasetCategories = {
      heritage: [
        'conservation-area', 'listed-building', 'listed-building-outline', 'scheduled-monument',
        'park-and-garden', 'world-heritage-site', 'world-heritage-site-buffer-zone',
        'battlefield', 'heritage-at-risk', 'protected-wreck-site', 'locally-listed-building',
        'archaeological-priority-area'
      ],
      environmental: [
        'flood-risk-zone', 'area-of-outstanding-natural-beauty', 'site-of-special-scientific-interest',
        'special-area-of-conservation', 'special-protection-area', 'ramsar', 'ancient-woodland',
        'green-belt', 'tree-preservation-zone', 'tree', 'national-nature-reserve',
        'local-nature-reserve', 'air-quality-management-area', 'agricultural-land-classification',
        'flood-storage-area', 'heritage-coast', 'nature-improvement-area',
        'best-and-most-versatile-agricultural-land'
      ],
      development: [
        'article-4-direction-area', 'brownfield-land', 'brownfield-site', 'central-activities-zone',
        'building-preservation-notice', 'certificate-of-immunity'
      ],
      transport: [
        'transport-access-node', 'railway-station', 'bus-stop'
      ],
      administrative: [
        'local-planning-authority', 'local-authority-district', 'parish', 'ward', 'national-park'
      ],
      infrastructure: [
        'infrastructure-project', 'educational-establishment', 'primary-school', 'secondary-school'
      ]
    };

    this.initialized = true;
  }

  // Helper methods for dataset filtering
  isRailwayStation(feature) {
    const stopType = feature.properties?.StopType?.toLowerCase() || '';
    const locality = feature.properties?.LocalityName?.toLowerCase() || '';
    return stopType.includes('rail') || locality.includes('station') || 
           feature.properties?.CommonName?.toLowerCase().includes('station');
  }

  isBusStop(feature) {
    const stopType = feature.properties?.StopType?.toLowerCase() || '';
    return stopType.includes('bus') || stopType === 'bcs' || stopType === 'bct';
  }

  isPrimarySchool(feature) {
    const phase = feature.properties?.PhaseOfEducation?.toLowerCase() || '';
    const type = feature.properties?.TypeOfEstablishment?.toLowerCase() || '';
    return phase.includes('primary') || type.includes('primary');
  }

  isSecondarySchool(feature) {
    const phase = feature.properties?.PhaseOfEducation?.toLowerCase() || '';
    const type = feature.properties?.TypeOfEstablishment?.toLowerCase() || '';
    return phase.includes('secondary') || type.includes('secondary');
  }

  isBestAndMostVersatileAgriculturalLand(feature) {
    const grade = feature.properties?.grade?.toLowerCase() || 
                  feature.properties?.Grade?.toLowerCase() || '';
    return ['1', '2', '3a', 'grade 1', 'grade 2', 'grade 3a'].some(g => grade.includes(g));
  }

  async analyzeSite(siteGeometry, siteAddress = null, analysisOptions = {}) {
    // Auto-initialize if not done already
    if (!this.initialized) {
      console.log('Auto-initializing SpatialAnalyzer...');
      await this.initializeConstraintLayers();
    }

    const analysisId = this.generateAnalysisId(siteGeometry);
    
    // Check cache first
    if (this.analysisCache.has(analysisId)) {
      return this.analysisCache.get(analysisId);
    }

    try {
      // Get site center point for API calls
      const siteCenter = turf.centroid(siteGeometry);
      const [longitude, latitude] = siteCenter.geometry.coordinates;

      // Determine which datasets to query based on analysis options
      const datasetsToQuery = this.selectDatasetsForAnalysis(analysisOptions);
      console.log(`Analyzing site with ${datasetsToQuery.length} datasets`);

      // Parallel analysis of different aspects with timeout protection
      const analysisPromises = [
        this.getOfficialConstraints(latitude, longitude, siteGeometry, datasetsToQuery)
          .catch(error => {
            console.warn('Official constraints analysis failed:', error);
            return { total: 0, constraints: [], error: error.message };
          }),
        
        this.analyzeProximities(siteCenter, analysisOptions)
          .catch(error => {
            console.warn('Proximity analysis failed:', error);
            return { summary: {}, details: [], error: error.message };
          }),
        
        this.calculateSiteMetrics(siteGeometry)
          .catch(error => {
            console.warn('Site metrics calculation failed:', error);
            return { area: 0, error: error.message };
          }),
        
        this.getStreetViewData(latitude, longitude)
          .catch(error => {
            console.warn('Street view data failed:', error);
            return { available: false, error: error.message };
          }),
        
        this.analyzeTransportAccess(latitude, longitude)
          .catch(error => {
            console.warn('Transport analysis failed:', error);
            return { error: error.message };
          })
      ];

      // Add timeout to prevent hanging
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Analysis timeout after 60 seconds')), 60000);
      });

      const [
        officialConstraints,
        proximityAnalysis,
        siteMetrics,
        streetViewData,
        transportAnalysis
      ] = await Promise.race([
        Promise.all(analysisPromises),
        timeoutPromise
      ]);

      const analysis = {
        id: analysisId,
        siteAddress,
        coordinates: { latitude, longitude },
        geometry: siteGeometry,
        constraints: officialConstraints,
        proximities: proximityAnalysis,
        metrics: siteMetrics,
        streetView: streetViewData,
        transport: transportAnalysis,
        evidence: this.generateSpatialEvidence(
          officialConstraints, 
          proximityAnalysis, 
          siteMetrics, 
          transportAnalysis
        ),
        planningAssessment: this.generatePlanningAssessment(
          officialConstraints,
          proximityAnalysis,
          analysisOptions
        ),
        timestamp: new Date(),
        confidence: this.calculateAnalysisConfidence(officialConstraints, proximityAnalysis),
        analysisOptions,
        performanceMetrics: {
          datasetsQueried: datasetsToQuery.length,
          useWebWorkers: this.useWebWorkers,
          cacheHit: false
        }
      };

      // Cache the result
      this.analysisCache.set(analysisId, analysis);
      
      return analysis;
    } catch (error) {
      console.error('Site analysis failed:', error);
      
      // Return a minimal analysis result instead of throwing
      return {
        id: analysisId,
        siteAddress,
        coordinates: { latitude: 0, longitude: 0 },
        geometry: siteGeometry,
        constraints: { total: 0, constraints: [], error: error.message },
        proximities: { summary: {}, details: [], error: error.message },
        metrics: { area: 0, error: error.message },
        streetView: { available: false, error: error.message },
        transport: { error: error.message },
        evidence: [],
        planningAssessment: {
          developmentPotential: 'unknown',
          riskLevel: 'unknown',
          keyOpportunities: [],
          keyConstraints: [],
          error: error.message
        },
        timestamp: new Date(),
        confidence: 0,
        analysisOptions,
        error: error.message
      };
    }
  }

  /**
   * Select datasets to query based on analysis requirements
   */
  selectDatasetsForAnalysis(options = {}) {
    // Ensure analyzer is initialized
    if (!this.initialized || !this.datasetCategories) {
      console.warn('SpatialAnalyzer not properly initialized, using basic dataset selection');
      return ['conservation-area', 'listed-building', 'flood-risk-zone', 'green-belt', 'local-planning-authority'];
    }

    const {
      includeHeritage = true,
      includeEnvironmental = true,
      includeDevelopment = true,
      includeTransport = true,
      includeInfrastructure = true,
      analysisType = 'comprehensive', // 'basic', 'comprehensive', 'heritage-focused', 'environmental-focused'
      developmentType = null // 'residential', 'commercial', 'industrial'
    } = options;

    let selectedDatasets = [];

    // Always include critical datasets
    const criticalDatasets = [
      'flood-risk-zone',
      'conservation-area',
      'listed-building',
      'green-belt',
      'article-4-direction-area'
    ];
    selectedDatasets.push(...criticalDatasets);

    // Add datasets based on analysis type
    switch (analysisType) {
      case 'basic':
        selectedDatasets.push(
          'local-planning-authority',
          'transport-access-node',
          'educational-establishment'
        );
        break;
        
      case 'heritage-focused':
        if (this.datasetCategories.heritage) {
          selectedDatasets.push(...this.datasetCategories.heritage);
        }
        selectedDatasets.push('archaeological-priority-area');
        break;
        
      case 'environmental-focused':
        if (this.datasetCategories.environmental) {
          selectedDatasets.push(...this.datasetCategories.environmental);
        }
        selectedDatasets.push('best-and-most-versatile-agricultural-land');
        break;
        
      case 'comprehensive':
      default:
        // Include all categories based on options
        if (includeHeritage && this.datasetCategories.heritage) {
          selectedDatasets.push(...this.datasetCategories.heritage);
        }
        if (includeEnvironmental && this.datasetCategories.environmental) {
          selectedDatasets.push(...this.datasetCategories.environmental);
        }
        if (includeDevelopment && this.datasetCategories.development) {
          selectedDatasets.push(...this.datasetCategories.development);
        }
        if (includeTransport && this.datasetCategories.transport) {
          selectedDatasets.push(...this.datasetCategories.transport);
        }
        if (includeInfrastructure && this.datasetCategories.infrastructure) {
          selectedDatasets.push(...this.datasetCategories.infrastructure);
        }
        if (this.datasetCategories.administrative) {
          selectedDatasets.push(...this.datasetCategories.administrative);
        }
        break;
    }

    // Add development-type specific datasets
    if (developmentType === 'residential') {
      selectedDatasets.push(
        'educational-establishment',
        'local-nature-reserve',
        'transport-access-node'
      );
    } else if (developmentType === 'commercial') {
      selectedDatasets.push(
        'central-activities-zone',
        'transport-access-node',
        'employment-area'
      );
    } else if (developmentType === 'industrial') {
      selectedDatasets.push(
        'air-quality-management-area',
        'flood-storage-area',
        'transport-access-node'
      );
    }

    // Remove duplicates and return
    return [...new Set(selectedDatasets)];
  }

  /**
   * Generate planning assessment based on analysis results
   */
  generatePlanningAssessment(constraints, proximities, options = {}) {
    const assessment = {
      developmentPotential: 'unknown',
      keyOpportunities: [],
      keyConstraints: [],
      planningStrategy: [],
      riskLevel: 'low',
      recommendedStudies: [],
      designConsiderations: []
    };

    // Assess development potential
    const criticalConstraints = constraints.critical?.length || 0;
    const highPriorityConstraints = constraints.constraints?.filter(c => 
      c.priority === 'high' && c.coverage > 10
    ).length || 0;

    if (criticalConstraints === 0 && highPriorityConstraints <= 1) {
      assessment.developmentPotential = 'high';
      assessment.riskLevel = 'low';
    } else if (criticalConstraints <= 1 && highPriorityConstraints <= 3) {
      assessment.developmentPotential = 'medium';
      assessment.riskLevel = 'medium';
    } else {
      assessment.developmentPotential = 'challenging';
      assessment.riskLevel = 'high';
    }

    // Identify key opportunities
    if (proximities.transport_accessibility?.ptal_score >= 4) {
      assessment.keyOpportunities.push('Excellent public transport accessibility');
    }
    if (proximities.education_accessibility?.rating === 'excellent') {
      assessment.keyOpportunities.push('Strong education accessibility for family housing');
    }
    if (constraints.byCategory?.development?.some(c => c.dataset === 'brownfield-land')) {
      assessment.keyOpportunities.push('Brownfield development opportunity');
    }

    // Identify key constraints
    constraints.critical?.forEach(constraint => {
      assessment.keyConstraints.push({
        type: constraint.dataset,
        description: constraint.description,
        coverage: constraint.coverage,
        impact: constraint.impactLevel
      });
    });

    // Planning strategy recommendations
    if (proximities.heritage_context?.context === 'high') {
      assessment.planningStrategy.push('Heritage-led design approach required');
      assessment.recommendedStudies.push('Heritage Impact Assessment');
    }
    if (proximities.environmental_context?.ecological_assessment_likely) {
      assessment.planningStrategy.push('Ecological mitigation strategy needed');
      assessment.recommendedStudies.push('Ecological Assessment');
    }
    if (constraints.intersecting?.some(c => c.dataset === 'flood-risk-zone')) {
      assessment.planningStrategy.push('Flood risk mitigation required');
      assessment.recommendedStudies.push('Flood Risk Assessment');
    }

    // Design considerations
    if (proximities.heritage_context?.context !== 'low') {
      assessment.designConsiderations.push('Respect historic character and setting');
    }
    if (proximities.transport_accessibility?.ptal_score >= 4) {
      assessment.designConsiderations.push('Reduced parking provision acceptable');
    }
    if (constraints.intersecting?.some(c => c.dataset === 'conservation-area')) {
      assessment.designConsiderations.push('High quality materials and detailing essential');
    }

    return assessment;
  }

  /**
   * Get official planning constraints from planning.data.gov.uk
   */
  async getOfficialConstraints(latitude, longitude, siteGeometry) {
    try {
      // Get all available datasets for the location
      const allConstraints = await this.planningDataAPI.getConstraintsForSite(latitude, longitude);
      
      // Group constraints by priority and category
      const constraintsByCategory = {
        heritage: [],
        environmental: [],
        development: [],
        transport: [],
        administrative: [],
        infrastructure: []
      };

      // Enhanced processing with spatial intersection analysis
      const processedConstraints = [];
      
      for (const constraint of allConstraints) {
        const intersection = this.calculateIntersection(siteGeometry, constraint.geometry);
        const coverage = intersection ? this.calculateCoverage(siteGeometry, intersection) : 0;
        
        // Determine constraint category
        const category = this.determineConstraintCategory(constraint.dataset);
        
        const processedConstraint = {
          ...constraint,
          intersection,
          coverage,
          category,
          impactLevel: this.assessConstraintImpact(constraint, coverage),
          planningImplications: this.deriveConstraintImplications(constraint, coverage),
          priority: this.getConstraintPriority(constraint.dataset),
          description: this.getConstraintDescription(constraint.dataset)
        };

        processedConstraints.push(processedConstraint);
        
        // Add to category groups
        if (constraintsByCategory[category]) {
          constraintsByCategory[category].push(processedConstraint);
        }
      }

      // Get derived datasets
      const derivedConstraints = await this.getDerivedConstraints(latitude, longitude, siteGeometry);
      processedConstraints.push(...derivedConstraints);

      // Sort by priority and coverage
      processedConstraints.sort((a, b) => {
        const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
        if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
          return priorityOrder[b.priority] - priorityOrder[a.priority];
        }
        return b.coverage - a.coverage;
      });

      return {
        total: processedConstraints.length,
        bySeverity: this.groupBySeverity(processedConstraints),
        byCategory: constraintsByCategory,
        byPriority: this.groupByPriority(processedConstraints),
        intersecting: processedConstraints.filter(c => c.coverage > 0),
        nearby: processedConstraints.filter(c => c.coverage === 0 && c.distance < 500),
        critical: processedConstraints.filter(c => c.priority === 'high' && c.coverage > 0),
        constraints: processedConstraints,
        summary: this.generateConstraintSummary(processedConstraints, constraintsByCategory)
      };
    } catch (error) {
      console.error('Failed to get official constraints:', error);
      return { total: 0, constraints: [], error: error.message };
    }
  }

  /**
   * Get constraints from derived datasets
   */
  async getDerivedConstraints(latitude, longitude, siteGeometry) {
    const derivedConstraints = [];
    
    try {
      // Get transport access nodes and filter for specific types
      const transportNodes = await this.planningDataAPI.searchByLocation(
        latitude, longitude, ['transport-access-node'], 50
      );

      // Derive railway stations
      const railwayStations = transportNodes.filter(node => this.isRailwayStation(node));
      for (const station of railwayStations) {
        const distance = this.calculateDistanceToFeature(
          turf.centroid(siteGeometry), station
        );
        derivedConstraints.push({
          dataset: 'railway-station',
          category: 'transport',
          priority: 'high',
          coverage: 0,
          distance,
          name: station.properties?.CommonName || 'Railway Station',
          description: 'Railway station access point',
          planningImplications: [`Public transport accessibility: ${this.getAccessibilityRating(distance)}`]
        });
      }

      // Derive bus stops
      const busStops = transportNodes.filter(node => this.isBusStop(node));
      for (const stop of busStops.slice(0, 10)) { // Limit to 10 closest
        const distance = this.calculateDistanceToFeature(
          turf.centroid(siteGeometry), stop
        );
        derivedConstraints.push({
          dataset: 'bus-stop',
          category: 'transport',
          priority: 'low',
          coverage: 0,
          distance,
          name: stop.properties?.CommonName || 'Bus Stop',
          description: 'Bus stop access point',
          planningImplications: [`Local bus accessibility within ${Math.round(distance)}m`]
        });
      }

      // Get educational establishments and filter
      const schools = await this.planningDataAPI.searchByLocation(
        latitude, longitude, ['educational-establishment'], 20
      );

      const primarySchools = schools.filter(school => this.isPrimarySchool(school));
      for (const school of primarySchools.slice(0, 5)) {
        const distance = this.calculateDistanceToFeature(
          turf.centroid(siteGeometry), school
        );
        derivedConstraints.push({
          dataset: 'primary-school',
          category: 'infrastructure',
          priority: 'medium',
          coverage: 0,
          distance,
          name: school.properties?.EstablishmentName || 'Primary School',
          description: 'Primary school facility',
          planningImplications: [`School accessibility: ${distance < 800 ? 'Excellent' : distance < 1200 ? 'Good' : 'Moderate'}`]
        });
      }

      // Get agricultural land and filter for best and most versatile
      const agriculturalLand = await this.planningDataAPI.getConstraintsForSite(latitude, longitude, ['agricultural-land-classification']);
      for (const land of agriculturalLand) {
        if (this.isBestAndMostVersatileAgriculturalLand(land)) {
          const intersection = this.calculateIntersection(siteGeometry, land.geometry);
          const coverage = intersection ? this.calculateCoverage(siteGeometry, intersection) : 0;
          
          if (coverage > 0) {
            derivedConstraints.push({
              dataset: 'best-and-most-versatile-agricultural-land',
              category: 'environmental',
              priority: 'medium',
              coverage,
              intersection,
              name: 'Best and Most Versatile Agricultural Land',
              description: 'High quality agricultural land (grades 1, 2, 3a)',
              planningImplications: ['Agricultural land assessment required', 'Soil management plan may be needed']
            });
          }
        }
      }

    } catch (error) {
      console.warn('Error getting derived constraints:', error);
    }

    return derivedConstraints;
  }

  /**
   * Determine the category of a constraint based on its dataset
   */
  determineConstraintCategory(dataset) {
    for (const [category, datasets] of Object.entries(this.datasetCategories)) {
      if (datasets.includes(dataset)) {
        return category;
      }
    }
    return 'other';
  }

  /**
   * Get the priority level for a dataset
   */
  getConstraintPriority(dataset) {
    const layer = this.constraintLayers.get(dataset);
    return layer?.priority || 'low';
  }

  /**
   * Get the description for a dataset
   */
  getConstraintDescription(dataset) {
    const layer = this.constraintLayers.get(dataset);
    return layer?.description || dataset;
  }

  /**
   * Group constraints by priority
   */
  groupByPriority(constraints) {
    return constraints.reduce((groups, constraint) => {
      const priority = constraint.priority;
      if (!groups[priority]) groups[priority] = [];
      groups[priority].push(constraint);
      return groups;
    }, {});
  }

  /**
   * Generate a summary of constraints
   */
  generateConstraintSummary(constraints, constraintsByCategory) {
    const summary = {
      totalConstraints: constraints.length,
      intersectingConstraints: constraints.filter(c => c.coverage > 0).length,
      highPriorityConstraints: constraints.filter(c => c.priority === 'high').length,
      categoryBreakdown: {},
      keyConstraints: [],
      planningComplexity: 'low'
    };

    // Calculate category breakdown
    for (const [category, categoryConstraints] of Object.entries(constraintsByCategory)) {
      summary.categoryBreakdown[category] = {
        total: categoryConstraints.length,
        intersecting: categoryConstraints.filter(c => c.coverage > 0).length,
        highPriority: categoryConstraints.filter(c => c.priority === 'high').length
      };
    }

    // Identify key constraints (high priority with coverage > 10%)
    summary.keyConstraints = constraints
      .filter(c => c.priority === 'high' && c.coverage > 10)
      .map(c => ({
        dataset: c.dataset,
        name: c.name,
        coverage: c.coverage,
        impact: c.impactLevel
      }));

    // Assess planning complexity
    const highPriorityIntersecting = constraints.filter(c => 
      c.priority === 'high' && c.coverage > 0
    ).length;
    
    if (highPriorityIntersecting >= 3) {
      summary.planningComplexity = 'high';
    } else if (highPriorityIntersecting >= 1 || summary.intersectingConstraints >= 5) {
      summary.planningComplexity = 'medium';
    }

    return summary;
  }

  /**
   * Get accessibility rating based on distance
   */
  getAccessibilityRating(distance) {
    if (distance <= 400) return 'Excellent';
    if (distance <= 800) return 'Very Good';
    if (distance <= 1200) return 'Good';
    if (distance <= 2000) return 'Moderate';
    return 'Poor';
  }

  /**
   * Analyze proximities to key features using planning data API datasets
   */
  async analyzeProximities(siteCenter) {
    const proximityTargets = [
      // Transport (critical for PTAL calculation)
      { 
        dataset: 'transport-access-node', 
        filter: this.isRailwayStation.bind(this),
        type: 'railway-station', 
        radius: 2000, 
        weight: 'high',
        description: 'Railway stations'
      },
      { 
        dataset: 'transport-access-node', 
        filter: this.isBusStop.bind(this),
        type: 'bus-stop', 
        radius: 800, 
        weight: 'medium',
        description: 'Bus stops'
      },
      
      // Education facilities
      { 
        dataset: 'educational-establishment', 
        filter: this.isPrimarySchool.bind(this),
        type: 'primary-school', 
        radius: 1200, 
        weight: 'high',
        description: 'Primary schools'
      },
      { 
        dataset: 'educational-establishment', 
        filter: this.isSecondarySchool.bind(this),
        type: 'secondary-school', 
        radius: 3000, 
        weight: 'medium',
        description: 'Secondary schools'
      },
      
      // Heritage and conservation features
      { 
        dataset: 'listed-building', 
        type: 'listed-building', 
        radius: 500, 
        weight: 'medium',
        description: 'Listed buildings'
      },
      { 
        dataset: 'conservation-area', 
        type: 'conservation-area', 
        radius: 1000, 
        weight: 'medium',
        description: 'Conservation areas'
      },
      { 
        dataset: 'scheduled-monument', 
        type: 'scheduled-monument', 
        radius: 1000, 
        weight: 'medium',
        description: 'Scheduled monuments'
      },
      
      // Environmental features
      { 
        dataset: 'ancient-woodland', 
        type: 'ancient-woodland', 
        radius: 500, 
        weight: 'medium',
        description: 'Ancient woodland'
      },
      { 
        dataset: 'local-nature-reserve', 
        type: 'local-nature-reserve', 
        radius: 2000, 
        weight: 'low',
        description: 'Local nature reserves'
      },
      
      // Development opportunities
      { 
        dataset: 'brownfield-land', 
        type: 'brownfield-land', 
        radius: 1000, 
        weight: 'low',
        description: 'Brownfield land'
      }
    ];

    const proximities = [];

    for (const target of proximityTargets) {
      try {
        let nearbyFeatures = await this.planningDataAPI.searchByLocation(
          siteCenter.geometry.coordinates[1], // lat
          siteCenter.geometry.coordinates[0], // lng
          [target.dataset],
          target.type === 'bus-stop' ? 50 : 30 // More bus stops needed for PTAL
        );

        // Apply filtering if specified
        if (target.filter) {
          nearbyFeatures = nearbyFeatures.filter(target.filter);
        }

        const processed = nearbyFeatures.map(feature => {
          const distance = this.calculateDistanceToFeature(siteCenter, feature);
          return {
            type: target.type,
            dataset: target.dataset,
            name: this.getFeatureName(feature, target.dataset),
            distance,
            within_radius: distance <= target.radius,
            weight: target.weight,
            accessibility_score: this.calculateAccessibilityScore(distance, target.radius),
            properties: this.extractRelevantProperties(feature, target.dataset)
          };
        }).filter(p => p.distance <= target.radius)
          .sort((a, b) => a.distance - b.distance);

        proximities.push({
          target_type: target.type,
          dataset: target.dataset,
          description: target.description,
          radius: target.radius,
          weight: target.weight,
          found: processed.length,
          features: processed.slice(0, target.type === 'bus-stop' ? 15 : 8), // More bus stops for PTAL
          accessibility_summary: this.summarizeAccessibility(processed, target),
          planning_relevance: this.assessPlanningRelevance(target.type, processed)
        });
      } catch (error) {
        console.warn(`Failed to analyze proximity to ${target.type}:`, error);
        proximities.push({
          target_type: target.type,
          dataset: target.dataset,
          description: target.description,
          error: error.message,
          found: 0,
          features: []
        });
      }
    }

    return {
      summary: this.summarizeProximityAnalysis(proximities),
      details: proximities,
      transport_accessibility: this.calculateTransportAccessibility(proximities),
      heritage_context: this.calculateHeritageContext(proximities),
      environmental_context: this.calculateEnvironmentalContext(proximities),
      education_accessibility: this.calculateEducationAccessibility(proximities)
    };
  }

  /**
   * Extract relevant properties from features based on dataset
   */
  extractRelevantProperties(feature, dataset) {
    const props = feature.properties || {};
    
    switch (dataset) {
      case 'transport-access-node':
        return {
          stopType: props.StopType,
          commonName: props.CommonName,
          localityName: props.LocalityName,
          stopPoint: props.StopPoint
        };
      case 'educational-establishment':
        return {
          establishmentName: props.EstablishmentName,
          phaseOfEducation: props.PhaseOfEducation,
          typeOfEstablishment: props.TypeOfEstablishment,
          establishmentStatus: props.EstablishmentStatus
        };
      case 'listed-building':
        return {
          name: props.name,
          grade: props.grade,
          listEntry: props['list-entry'],
          listedBuildingGrade: props['listed-building-grade']
        };
      case 'conservation-area':
        return {
          name: props.name,
          documentation: props.documentation,
          notes: props.notes
        };
      default:
        return {
          name: props.name,
          reference: props.reference,
          notes: props.notes
        };
    }
  }

  /**
   * Get appropriate name for a feature based on dataset
   */
  getFeatureName(feature, dataset) {
    const props = feature.properties || {};
    
    switch (dataset) {
      case 'transport-access-node':
        return props.CommonName || props.LocalityName || 'Transport Access Point';
      case 'educational-establishment':
        return props.EstablishmentName || 'Educational Establishment';
      case 'listed-building':
        return props.name || `Listed Building (${props.grade || 'Unknown Grade'})`;
      case 'conservation-area':
        return props.name || 'Conservation Area';
      default:
        return props.name || props.reference || feature.dataset || 'Unnamed Feature';
    }
  }

  /**
   * Assess planning relevance of proximity features
   */
  assessPlanningRelevance(featureType, features) {
    if (features.length === 0) return { relevance: 'none', notes: [] };
    
    const closest = features[0];
    const notes = [];
    
    switch (featureType) {
      case 'railway-station':
        if (closest.distance <= 800) {
          notes.push('Excellent public transport accessibility');
          notes.push('Reduced car parking requirements likely');
          notes.push('High PTAL score expected');
          return { relevance: 'high', notes };
        } else if (closest.distance <= 1200) {
          notes.push('Good public transport accessibility');
          notes.push('Moderate PTAL score expected');
          return { relevance: 'medium', notes };
        }
        break;
        
      case 'primary-school':
        if (closest.distance <= 800) {
          notes.push('Excellent school accessibility for families');
          notes.push('Family housing development strongly supported');
          return { relevance: 'high', notes };
        }
        break;
        
      case 'listed-building':
        if (closest.distance <= 100) {
          notes.push('Heritage impact assessment required');
          notes.push('Design must respect historic context');
          notes.push('Height restrictions likely');
          return { relevance: 'high', notes };
        } else if (closest.distance <= 300) {
          notes.push('Heritage considerations in design');
          return { relevance: 'medium', notes };
        }
        break;
        
      case 'conservation-area':
        if (closest.distance <= 50) {
          notes.push('Development within/adjacent to conservation area');
          notes.push('Conservation area assessment required');
          notes.push('Strict design controls apply');
          return { relevance: 'high', notes };
        }
        break;
        
      case 'ancient-woodland':
        if (closest.distance <= 100) {
          notes.push('Ancient woodland buffer zone considerations');
          notes.push('Ecological assessment required');
          notes.push('Root protection area restrictions');
          return { relevance: 'high', notes };
        }
        break;
    }
    
    return { relevance: 'low', notes };
  }

  /**
   * Calculate heritage context
   */
  calculateHeritageContext(proximities) {
    const heritageFeatures = proximities.filter(p => 
      ['listed-building', 'conservation-area', 'scheduled-monument'].includes(p.target_type)
    );
    
    const nearbyHeritage = heritageFeatures.filter(p => p.found > 0);
    const density = nearbyHeritage.length;
    
    let context = 'low';
    if (density >= 3) context = 'high';
    else if (density >= 2) context = 'medium';
    
    return {
      context,
      heritage_features: nearbyHeritage.length,
      closest_heritage: nearbyHeritage.length > 0 ? 
        Math.min(...nearbyHeritage.flatMap(p => p.features.map(f => f.distance))) : null,
      assessment_required: context !== 'low'
    };
  }

  /**
   * Calculate environmental context
   */
  calculateEnvironmentalContext(proximities) {
    const environmentalFeatures = proximities.filter(p => 
      ['ancient-woodland', 'local-nature-reserve'].includes(p.target_type)
    );
    
    const nearbyEnvironmental = environmentalFeatures.filter(p => p.found > 0);
    
    return {
      environmental_features: nearbyEnvironmental.length,
      closest_environmental: nearbyEnvironmental.length > 0 ? 
        Math.min(...nearbyEnvironmental.flatMap(p => p.features.map(f => f.distance))) : null,
      ecological_assessment_likely: nearbyEnvironmental.some(p => 
        p.features.some(f => f.distance <= 200)
      )
    };
  }

  /**
   * Calculate education accessibility
   */
  calculateEducationAccessibility(proximities) {
    const primarySchools = proximities.find(p => p.target_type === 'primary-school');
    const secondarySchools = proximities.find(p => p.target_type === 'secondary-school');
    
    const primaryDistance = primarySchools?.features?.[0]?.distance || null;
    const secondaryDistance = secondarySchools?.features?.[0]?.distance || null;
    
    let rating = 'poor';
    if (primaryDistance && primaryDistance <= 800) rating = 'excellent';
    else if (primaryDistance && primaryDistance <= 1200) rating = 'good';
    else if (primaryDistance && primaryDistance <= 2000) rating = 'moderate';
    
    return {
      rating,
      primary_school_distance: primaryDistance,
      secondary_school_distance: secondaryDistance,
      family_housing_suitability: rating === 'excellent' || rating === 'good'
    };
  }

  /**
   * Calculate site metrics (area, perimeter, etc.) with worker support
   */
  async calculateSiteMetrics(geometry) {
    try {
      // Try to use web worker for heavy calculation
      if (this.useWebWorkers && this.workerPool.length > 0) {
        return await this.executeInWorker('calculateSiteMetrics', { geometry });
      }
      
      // Fallback to main thread calculation
      const area = turf.area(geometry);
      const bbox = turf.bbox(geometry);
      const centroid = turf.centroid(geometry);
      
      // Calculate perimeter
      const perimeter = this.calculatePerimeter(geometry);
      
      // Calculate frontage (simplified - actual implementation would need road data)
      const frontageLength = await this.estimateFrontageLength(geometry);
      
      // Estimate developable area (accounting for constraints)
      const developableArea = area * 0.8; // Simplified assumption

      return {
        area: Math.round(area),
        perimeter: Math.round(perimeter),
        frontageLength: Math.round(frontageLength || 0),
        developableArea: Math.round(developableArea),
        centroid: centroid.geometry.coordinates,
        boundingBox: bbox,
        aspectRatio: this.calculateAspectRatio(bbox),
        compactness: this.calculateCompactness(area, perimeter)
      };
    } catch (error) {
      console.error('Site metrics calculation failed:', error);
      return {
        area: 0,
        perimeter: 0,
        frontageLength: 0,
        developableArea: 0,
        centroid: [0, 0],
        boundingBox: [0, 0, 0, 0],
        aspectRatio: 1,
        compactness: 0,
        error: error.message
      };
    }
  }

  /**
   * Get Street View data from Google API
   */
  async getStreetViewData(latitude, longitude) {
    if (!this.googleMapsApiKey) {
      return { available: false, reason: 'No API key provided' };
    }

    try {
      // Check if Street View is available
      const metadataUrl = `https://maps.googleapis.com/maps/api/streetview/metadata?location=${latitude},${longitude}&key=${this.googleMapsApiKey}`;
      
      const response = await fetch(metadataUrl);
      const metadata = await response.json();

      if (metadata.status === 'OK') {
        return {
          available: true,
          location: metadata.location,
          date: metadata.date,
          imageUrl: `https://maps.googleapis.com/maps/api/streetview?size=640x640&location=${latitude},${longitude}&key=${this.googleMapsApiKey}`,
          metadata
        };
      } else {
        return { available: false, reason: metadata.status };
      }
    } catch (error) {
      console.error('Street View API error:', error);
      return { available: false, reason: 'API error' };
    }
  }

  /**
   * Analyze transport accessibility
   */
  async analyzeTransportAccess(latitude, longitude) {
    try {
      // Transport datasets might not be available - provide fallback analysis
      console.log('Attempting transport accessibility analysis...');
      
      // Try to get transport data, but don't fail if unavailable
      const [stations, busStops] = await Promise.all([
        // Try fewer, more common dataset names for transport
        this.getTransportData(latitude, longitude, ['station'], 5, 'stations'),
        this.getTransportData(latitude, longitude, ['transport'], 10, 'transport stops')
      ]);

      // Provide basic analysis even without transport data
      const transportAnalysis = {
        accessibility: {
          score: 60, // Neutral score when data unavailable
          rating: 'unknown',
          details: 'Transport data unavailable - manual assessment recommended'
        },
        nearestStation: null,
        stationDistance: null,
        stationAccessibility: 'unknown',
        busStops: [],
        busAccessibility: 'unknown',
        transitScore: 50,
        walkingAccessibility: 'requires_assessment',
        cyclingAccessibility: 'requires_assessment'
      };

      // If we got station data, use it
      if (stations && stations.length > 0) {
        const nearestStation = this.findNearestFeature([latitude, longitude], stations);
        if (nearestStation) {
          transportAnalysis.nearestStation = nearestStation;
          transportAnalysis.stationDistance = nearestStation.distance;
          transportAnalysis.stationAccessibility = this.getAccessibilityRating(nearestStation.distance);
          transportAnalysis.accessibility.score = Math.min(90, 80 - (nearestStation.distance / 50));
          transportAnalysis.accessibility.rating = transportAnalysis.stationAccessibility;
          transportAnalysis.accessibility.details = `Nearest station: ${nearestStation.distance}m away`;
        }
      }

      // If we got bus data, use it
      if (busStops && busStops.length > 0) {
        const nearestBusStops = busStops
          .map(stop => ({
            ...stop,
            distance: this.calculateDistance([latitude, longitude], this.getFeatureCoordinates(stop))
          }))
          .filter(stop => stop.distance <= 400)
          .sort((a, b) => a.distance - b.distance)
          .slice(0, 5);
          
        transportAnalysis.busStops = nearestBusStops;
        if (nearestBusStops.length > 0) {
          transportAnalysis.busAccessibility = 'good';
          transportAnalysis.transitScore = Math.max(transportAnalysis.transitScore, 70);
          transportAnalysis.accessibility.score = Math.max(transportAnalysis.accessibility.score, 65);
          transportAnalysis.accessibility.rating = 'moderate';
          transportAnalysis.accessibility.details = `${nearestBusStops.length} bus stops within 400m`;
        }
      }

      console.log('Transport accessibility analysis completed');
      return transportAnalysis;
      
    } catch (error) {
      console.error('Transport analysis failed:', error);
      return {
        accessibility: {
          score: 50,
          rating: 'unknown',
          details: `Transport analysis failed: ${error.message}`
        },
        nearestStation: null,
        stationDistance: null,
        stationAccessibility: 'unknown',
        busStops: [],
        busAccessibility: 'unknown',
        transitScore: 50,
        walkingAccessibility: 'requires_assessment',
        cyclingAccessibility: 'requires_assessment'
      };
    }
  }

  /**
   * Generate spatial evidence items
   */
  generateSpatialEvidence(constraints, proximities, metrics, transport) {
    const evidence = [];

    // Constraint evidence
    if (constraints.intersecting && constraints.intersecting.length > 0) {
      constraints.intersecting.forEach(constraint => {
        evidence.push({
          type: 'constraint_intersection',
          category: constraint.category,
          description: `Site ${constraint.coverage > 50 ? 'primarily within' : 'partially overlaps'} ${constraint.name}`,
          impact: constraint.impactLevel,
          coverage: constraint.coverage,
          policies: constraint.relevantPolicies,
          confidence: 'high'
        });
      });
    }

    // Proximity evidence
    if (proximities.details) {
      proximities.details.forEach(proximity => {
        if (proximity.found > 0) {
          const nearest = proximity.features[0];
          evidence.push({
            type: 'proximity',
            category: 'accessibility',
            description: `${nearest.distance}m to nearest ${proximity.target_type.replace('-', ' ')}`,
            distance: nearest.distance,
            accessibility_score: nearest.accessibility_score,
            confidence: 'high'
          });
        }
      });
    }

    // Site metrics evidence
    if (metrics) {
      evidence.push({
        type: 'site_metrics',
        category: 'development_capacity',
        description: `Site area: ${metrics.area}m (${(metrics.area / 10000).toFixed(2)} hectares)`,
        area: metrics.area,
        developable_area: metrics.developableArea,
        confidence: 'high'
      });

      if (metrics.frontageLength > 0) {
        evidence.push({
          type: 'site_metrics',
          category: 'access',
          description: `Estimated frontage length: ${metrics.frontageLength}m`,
          frontage: metrics.frontageLength,
          confidence: 'medium'
        });
      }
    }

    // Transport evidence
    if (transport && transport.nearest_station) {
      evidence.push({
        type: 'transport',
        category: 'accessibility',
        description: `${transport.nearest_station.distance}m to ${transport.nearest_station.name} (${transport.nearest_station.walking_time} min walk)`,
        ptal_score: transport.ptal_score,
        accessibility_rating: transport.accessibility_rating,
        confidence: 'high'
      });
    }

    return evidence;
  }

  // Helper methods
  generateAnalysisId(geometry) {
    const coords = turf.centroid(geometry).geometry.coordinates;
    return `analysis_${coords[0].toFixed(6)}_${coords[1].toFixed(6)}_${Date.now()}`;
  }

  calculateIntersection(siteGeometry, constraintGeometry) {
    if (!constraintGeometry) return null;
    try {
      return turf.intersect(siteGeometry, constraintGeometry);
    } catch (error) {
      return null;
    }
  }

  calculateCoverage(siteGeometry, intersection) {
    if (!intersection) return 0;
    try {
      const siteArea = turf.area(siteGeometry);
      const intersectionArea = turf.area(intersection);
      return (intersectionArea / siteArea) * 100;
    } catch (error) {
      return 0;
    }
  }

  assessConstraintImpact(constraint, coverage) {
    if (coverage === 0) return 'none';
    if (constraint.severity === 'critical') return coverage > 10 ? 'critical' : 'high';
    if (constraint.severity === 'high') return coverage > 25 ? 'high' : 'medium';
    if (constraint.severity === 'medium') return coverage > 50 ? 'medium' : 'low';
    return 'low';
  }

  deriveConstraintImplications(constraint, coverage) {
    const implications = [];
    
    if (coverage > 0) {
      implications.push(`${constraint.category} assessment required`);
      
      if (constraint.category === 'heritage') {
        implications.push('Heritage statement required');
        if (coverage > 25) implications.push('Specialist heritage consultant recommended');
      }
      
      if (constraint.category === 'environmental') {
        implications.push('Environmental impact assessment may be required');
        if (coverage > 50) implications.push('Ecological survey essential');
      }
    }
    
    return implications;
  }

  groupBySeverity(constraints) {
    return constraints.reduce((groups, constraint) => {
      const severity = constraint.severity;
      if (!groups[severity]) groups[severity] = [];
      groups[severity].push(constraint);
      return groups;
    }, {});
  }

  groupByCategory(constraints) {
    return constraints.reduce((groups, constraint) => {
      const category = constraint.category;
      if (!groups[category]) groups[category] = [];
      groups[category].push(constraint);
      return groups;
    }, {});
  }

  calculatePerimeter(geometry) {
    try {
      return turf.length(turf.polygonToLine(geometry), { units: 'meters' });
    } catch (error) {
      return 0;
    }
  }

  async estimateFrontageLength(geometry) {
    // Simplified - would need actual road network data
    const bbox = turf.bbox(geometry);
    const width = turf.distance([bbox[0], bbox[1]], [bbox[2], bbox[1]], { units: 'meters' });
    const height = turf.distance([bbox[0], bbox[1]], [bbox[0], bbox[3]], { units: 'meters' });
    return Math.min(width, height); // Assume frontage is on shortest side
  }

  calculateAspectRatio(bbox) {
    const width = bbox[2] - bbox[0];
    const height = bbox[3] - bbox[1];
    return width / height;
  }

  calculateCompactness(area, perimeter) {
    // Isoperimetric quotient - measures how close to a circle the shape is
    return (4 * Math.PI * area) / (perimeter * perimeter);
  }

  calculateDistanceToFeature(point, feature) {
    const featureCoords = this.getFeatureCoordinates(feature);
    return this.calculateDistance(point.geometry.coordinates, featureCoords);
  }

  getFeatureCoordinates(feature) {
    if (feature.geometry.type === 'Point') {
      return feature.geometry.coordinates;
    } else {
      return turf.centroid(feature).geometry.coordinates;
    }
  }

  calculateDistance(coords1, coords2) {
    return turf.distance(coords1, coords2, { units: 'meters' });
  }

  findNearestFeature(point, features) {
    if (!features || features.length === 0) return null;
    
    let nearest = null;
    let minDistance = Infinity;
    
    features.forEach(feature => {
      const distance = this.calculateDistance(point, this.getFeatureCoordinates(feature));
      if (distance < minDistance) {
        minDistance = distance;
        nearest = { ...feature, distance };
      }
    });
    
    return nearest;
  }

  calculateAccessibilityScore(distance, maxRadius) {
    return Math.max(0, ((maxRadius - distance) / maxRadius) * 100);
  }

  summarizeAccessibility(features, target) {
    if (features.length === 0) return { rating: 'poor', score: 0 };
    
    const avgScore = features.reduce((sum, f) => sum + f.accessibility_score, 0) / features.length;
    
    let rating;
    if (avgScore >= 80) rating = 'excellent';
    else if (avgScore >= 60) rating = 'good';
    else if (avgScore >= 40) rating = 'fair';
    else rating = 'poor';
    
    return { rating, score: Math.round(avgScore), count: features.length };
  }

  summarizeProximityAnalysis(proximities) {
    const summary = {
      total_categories: proximities.length,
      accessible_categories: proximities.filter(p => p.found > 0).length,
      overall_rating: 'calculating...'
    };
    
    // Calculate overall accessibility rating
    const scores = proximities
      .filter(p => p.accessibility_summary.score > 0)
      .map(p => p.accessibility_summary.score);
    
    if (scores.length > 0) {
      const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
      if (avgScore >= 70) summary.overall_rating = 'excellent';
      else if (avgScore >= 50) summary.overall_rating = 'good';
      else if (avgScore >= 30) summary.overall_rating = 'fair';
      else summary.overall_rating = 'poor';
    } else {
      summary.overall_rating = 'poor';
    }
    
    return summary;
  }

  calculateTransportAccessibility(proximities) {
    const stationProximity = proximities.find(p => p.target_type === 'railway-station');
    const hasNearbyStation = stationProximity && stationProximity.found > 0;
    
    return {
      has_rail_access: hasNearbyStation,
      station_distance: hasNearbyStation ? stationProximity.features[0].distance : null,
      transport_rating: hasNearbyStation ? 'good' : 'car-dependent'
    };
  }

  calculatePTALScore(nearestStation, busStops) {
    let score = 0;
    
    // Rail accessibility
    if (nearestStation && nearestStation.distance <= 960) {
      const railScore = Math.max(0, 10 - (nearestStation.distance / 96));
      score += railScore;
    }
    
    // Bus accessibility
    const accessibleBusStops = busStops.filter(stop => stop.distance <= 480);
    if (accessibleBusStops.length > 0) {
      const busScore = Math.min(accessibleBusStops.length * 2, 10);
      score += busScore;
    }
    
    return Math.min(score, 10);
  }

  getPTALRating(score) {
    if (score >= 8) return 'Excellent (6a/6b)';
    if (score >= 6) return 'Very Good (5/6a)';
    if (score >= 4) return 'Good (3/4)';
    if (score >= 2) return 'Moderate (2/3)';
    return 'Poor (0/1)';
  }

  getCarParkingStandard(ptalScore) {
    if (ptalScore >= 6) return 'Car-free development possible';
    if (ptalScore >= 4) return 'Reduced parking standards';
    if (ptalScore >= 2) return 'Standard parking requirements';
    return 'Higher parking provision may be needed';
  }

  /**
   * Get information about available datasets and their sources
   */
  getAvailableDatasets() {
    const datasets = {};
    
    for (const [name, config] of this.constraintLayers) {
      datasets[name] = {
        ...config,
        available: config.source === 'planning_data_api' || config.source === 'derived',
        entityCount: this.getDatasetEntityCount(config.dataset),
        lastUpdated: config.lastUpdated,
        coverage: config.source === 'planning_data_api' ? 'England' : 'Variable'
      };
    }

    return {
      datasets,
      totalDatasets: Object.keys(datasets).length,
      availableDatasets: Object.values(datasets).filter(d => d.available).length,
      categories: this.datasetCategories,
      datasetsByCategory: this.groupDatasetsByCategory(),
      recommendedCombinations: this.getRecommendedDatasetCombinations()
    };
  }

  /**
   * Get entity count for datasets (based on the provided data)
   */
  getDatasetEntityCount(dataset) {
    const entityCounts = {
      'conservation-area': 11388,
      'listed-building': 378171,
      'listed-building-outline': 61934,
      'scheduled-monument': 20015,
      'park-and-garden': 1718,
      'world-heritage-site': 20,
      'world-heritage-site-buffer-zone': 9,
      'battlefield': 47,
      'heritage-at-risk': 5464,
      'protected-wreck-site': 57,
      'locally-listed-building': 448,
      'archaeological-priority-area': 738,
      'flood-risk-zone': 780636,
      'area-of-outstanding-natural-beauty': 34,
      'site-of-special-scientific-interest': 4129,
      'special-area-of-conservation': 260,
      'special-protection-area': 88,
      'ramsar': 73,
      'ancient-woodland': 44373,
      'green-belt': 188,
      'tree-preservation-zone': 44473,
      'tree': 115299,
      'national-nature-reserve': 223,
      'local-nature-reserve': 1710,
      'air-quality-management-area': 498,
      'agricultural-land-classification': 585,
      'flood-storage-area': 509,
      'heritage-coast': 32,
      'nature-improvement-area': 12,
      'article-4-direction-area': 4373,
      'brownfield-land': 37228,
      'brownfield-site': 2852,
      'central-activities-zone': 10,
      'building-preservation-notice': 10,
      'certificate-of-immunity': 384,
      'local-planning-authority': 337,
      'local-authority-district': 344,
      'parish': 10907,
      'ward': 6817,
      'national-park': 10,
      'transport-access-node': 361132,
      'infrastructure-project': 233,
      'educational-establishment': 47047,
      'built-up-area': 7157,
      'title-boundary': 2435130
    };
    
    return entityCounts[dataset] || 0;
  }

  /**
   * Group datasets by category for easier navigation
   */
  groupDatasetsByCategory() {
    const grouped = {};
    
    for (const [category, datasets] of Object.entries(this.datasetCategories)) {
      grouped[category] = datasets.map(dataset => {
        const config = this.constraintLayers.get(dataset);
        return {
          dataset,
          name: config?.description || dataset,
          priority: config?.priority || 'low',
          type: config?.type || 'unknown',
          entityCount: this.getDatasetEntityCount(dataset),
          available: config?.source === 'planning_data_api' || config?.source === 'derived'
        };
      }).filter(d => d.available);
    }
    
    return grouped;
  }

  /**
   * Get recommended dataset combinations for different use cases
   */
  getRecommendedDatasetCombinations() {
    return {
      'basic-planning-check': {
        description: 'Essential datasets for basic planning feasibility',
        datasets: [
          'conservation-area',
          'listed-building',
          'flood-risk-zone',
          'green-belt',
          'local-planning-authority'
        ],
        estimatedQueryTime: '2-5 seconds'
      },
      'heritage-assessment': {
        description: 'Comprehensive heritage constraint analysis',
        datasets: [
          'conservation-area',
          'listed-building',
          'listed-building-outline',
          'scheduled-monument',
          'park-and-garden',
          'world-heritage-site',
          'battlefield',
          'heritage-at-risk',
          'archaeological-priority-area'
        ],
        estimatedQueryTime: '5-10 seconds'
      },
      'environmental-assessment': {
        description: 'Environmental and ecological constraints',
        datasets: [
          'flood-risk-zone',
          'area-of-outstanding-natural-beauty',
          'site-of-special-scientific-interest',
          'special-area-of-conservation',
          'special-protection-area',
          'ramsar',
          'ancient-woodland',
          'green-belt',
          'tree-preservation-zone',
          'agricultural-land-classification'
        ],
        estimatedQueryTime: '5-10 seconds'
      },
      'residential-development': {
        description: 'Key datasets for residential development assessment',
        datasets: [
          'conservation-area',
          'listed-building',
          'flood-risk-zone',
          'green-belt',
          'educational-establishment',
          'transport-access-node',
          'local-nature-reserve',
          'article-4-direction-area'
        ],
        estimatedQueryTime: '5-8 seconds'
      },
      'commercial-development': {
        description: 'Datasets relevant for commercial development',
        datasets: [
          'conservation-area',
          'listed-building',
          'flood-risk-zone',
          'central-activities-zone',
          'transport-access-node',
          'article-4-direction-area',
          'brownfield-land'
        ],
        estimatedQueryTime: '3-7 seconds'
      },
      'comprehensive-analysis': {
        description: 'Full constraint and opportunity analysis',
        datasets: Object.keys(this.constraintLayers.keys()),
        estimatedQueryTime: '10-30 seconds'
      }
    };
  }

  /**
   * Check dataset availability and status
   */
  async checkDatasetStatus(datasets = null) {
    const datasetsToCheck = datasets || Array.from(this.constraintLayers.keys());
    const status = {};
    
    for (const dataset of datasetsToCheck) {
      const config = this.constraintLayers.get(dataset);
      if (!config) {
        status[dataset] = { available: false, error: 'Dataset not configured' };
        continue;
      }
      
      try {
        if (config.source === 'planning_data_api') {
          // Test API availability
          const testResult = await this.planningDataAPI.testDatasetAvailability(config.dataset);
          status[dataset] = {
            available: testResult.available,
            lastChecked: new Date(),
            entityCount: this.getDatasetEntityCount(config.dataset),
            apiStatus: testResult.status
          };
        } else if (config.source === 'derived') {
          // Check if parent dataset is available
          const parentAvailable = await this.planningDataAPI.testDatasetAvailability(config.deriveFrom);
          status[dataset] = {
            available: parentAvailable.available,
            lastChecked: new Date(),
            derivedFrom: config.deriveFrom,
            apiStatus: parentAvailable.status
          };
        } else {
          status[dataset] = {
            available: false,
            error: 'External data source not implemented'
          };
        }
      } catch (error) {
        status[dataset] = {
          available: false,
          error: error.message,
          lastChecked: new Date()
        };
      }
    }
    
    return status;
  }

  /**
   * Clean up worker pool
   */
  destroyWorkerPool() {
    if (this.workerPool) {
      this.workerPool.forEach(({ worker }) => {
        worker.terminate();
      });
      this.workerPool = [];
    }
  }

  calculateAnalysisConfidence(constraints, proximities) {
    let confidence = 100;
    
    // Reduce confidence if data sources failed
    if (constraints.error) confidence -= 30;
    if (proximities.error) confidence -= 20;
    
    // Reduce confidence if limited data available
    if (constraints.total === 0) confidence -= 15;
    if (proximities.summary.accessible_categories < 3) confidence -= 10;
    
    return Math.max(confidence, 0);
  }

  /**
   * Batch analysis for multiple sites
   */
  async analyzeSites(sites, analysisOptions = {}) {
    const results = [];
    const batchSize = analysisOptions.batchSize || 5;
    
    for (let i = 0; i < sites.length; i += batchSize) {
      const batch = sites.slice(i, i + batchSize);
      const batchPromises = batch.map(site => 
        this.analyzeSite(site.geometry, site.address, analysisOptions)
          .catch(error => ({
            error: error.message,
            site: site
          }))
      );
      
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);
      
      // Small delay between batches to avoid overwhelming the API
      if (i + batchSize < sites.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    return results;
  }

  /**
   * Export analysis results in different formats
   */
  exportAnalysis(analysis, format = 'json') {
    switch (format.toLowerCase()) {
      case 'geojson':
        return this.exportAsGeoJSON(analysis);
      case 'summary':
        return this.exportAsSummary(analysis);
      case 'csv':
        return this.exportAsCSV(analysis);
      default:
        return analysis;
    }
  }

  exportAsGeoJSON(analysis) {
    return {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          geometry: analysis.geometry,
          properties: {
            analysisId: analysis.id,
            address: analysis.siteAddress,
            developmentPotential: analysis.planningAssessment?.developmentPotential,
            constraintCount: analysis.constraints?.total || 0,
            riskLevel: analysis.planningAssessment?.riskLevel,
            confidence: analysis.confidence,
            timestamp: analysis.timestamp
          }
        }
      ]
    };
  }

  exportAsSummary(analysis) {
    return {
      siteId: analysis.id,
      address: analysis.siteAddress,
      coordinates: analysis.coordinates,
      area: analysis.metrics?.area,
      developmentPotential: analysis.planningAssessment?.developmentPotential,
      keyConstraints: analysis.planningAssessment?.keyConstraints || [],
      keyOpportunities: analysis.planningAssessment?.keyOpportunities || [],
      riskLevel: analysis.planningAssessment?.riskLevel,
      confidence: analysis.confidence,
      summary: {
        totalConstraints: analysis.constraints?.total || 0,
        intersectingConstraints: analysis.constraints?.intersecting?.length || 0,
        criticalConstraints: analysis.constraints?.critical?.length || 0,
        ptalScore: analysis.transport?.ptal_score,
        heritageContext: analysis.proximities?.heritage_context?.context,
        environmentalSensitivity: analysis.proximities?.environmental_context?.ecological_assessment_likely
      }
    };
  }

  exportAsCSV(analysis) {
    const summary = this.exportAsSummary(analysis);
    const headers = [
      'Site ID', 'Address', 'Latitude', 'Longitude', 'Area (m)',
      'Development Potential', 'Risk Level', 'Total Constraints',
      'Critical Constraints', 'PTAL Score', 'Heritage Context', 'Confidence'
    ];
    
    const row = [
      summary.siteId,
      summary.address || '',
      summary.coordinates?.latitude || '',
      summary.coordinates?.longitude || '',
      summary.area || '',
      summary.developmentPotential || '',
      summary.riskLevel || '',
      summary.summary.totalConstraints,
      summary.summary.criticalConstraints,
      summary.summary.ptalScore || '',
      summary.summary.heritageContext || '',
      summary.confidence
    ];
    
    return {
      headers: headers.join(','),
      data: row.join(',')
    };
  }

  async calculateGeometricProperties(geometry) {
    const area = turf.area(geometry);
    const perimeter = turf.length(turf.polygonToLine(geometry), { units: 'meters' });
    const centroid = turf.centroid(geometry);
    const bbox = turf.bbox(geometry);
    
    // Calculate frontage (assume road frontage is shortest side)
    const frontageLength = Math.min(
      turf.distance([bbox[0], bbox[1]], [bbox[2], bbox[1]]),
      turf.distance([bbox[0], bbox[1]], [bbox[0], bbox[3]])
    ) * 1000;
    
    const plotRatio = await this.estimatePlotRatio(geometry);

    return {
      area: Math.round(area),
      perimeter: Math.round(perimeter),
      frontageLength: Math.round(frontageLength),
      plotRatio: plotRatio,
      centroid: centroid.geometry.coordinates,
      boundingBox: bbox,
      aspectRatio: this.calculateAspectRatio(bbox)
    };
  }

  async calculateIntersections(siteGeometry) {
    const intersections = {};
    
    for (const [layerName, layer] of this.constraintLayers) {
      if (layer.features.length === 0) continue;
      
      const layerIntersections = [];
      
      for (const feature of layer.features) {
        try {
          let intersectionResult = null;
          
          if (layer.type === 'polygon') {
            const intersection = turf.intersect(siteGeometry, feature.geometry);
            if (intersection) {
              const intersectionArea = turf.area(intersection);
              const coveragePercent = (intersectionArea / turf.area(siteGeometry)) * 100;
              
              intersectionResult = {
                featureId: feature.id || feature.properties?.id,
                name: feature.properties?.name || layerName,
                area: Math.round(intersectionArea),
                coveragePercent: Math.round(coveragePercent * 100) / 100,
                geometry: intersection
              };
            }
          } else if (layer.type === 'point') {
            const isInside = turf.booleanPointInPolygon(feature.geometry, siteGeometry);
            if (isInside) {
              intersectionResult = {
                featureId: feature.id || feature.properties?.id,
                name: feature.properties?.name || layerName,
                coordinates: feature.geometry.coordinates,
                withinSite: true
              };
            }
          }
          
          if (intersectionResult) {
            layerIntersections.push(intersectionResult);
          }
        } catch (error) {
          console.warn(`Error calculating intersection with ${layerName}:`, error);
        }
      }
      
      if (layerIntersections.length > 0) {
        intersections[layerName] = layerIntersections;
      }
    }
    
    return intersections;
  }

  async calculateProximities(siteGeometry) {
    const centroid = turf.centroid(siteGeometry);
    const proximities = {};
    
    // Define search radii for different feature types
    const searchRadii = {
      railwayStations: 2000, // 2km
      busStops: 500, // 500m
      schools: 1000, // 1km
      hospitals: 5000, // 5km
      townCentres: 10000, // 10km
      listedBuildings: 500, // 500m
      scheduledMonuments: 1000 // 1km
    };
    
    for (const [layerName, layer] of this.constraintLayers) {
      if (layer.type !== 'point' || layer.features.length === 0) continue;
      
      const searchRadius = searchRadii[layerName] || 1000; // Default 1km
      const nearbyFeatures = [];
      
      for (const feature of layer.features) {
        const distance = turf.distance(centroid, feature, { units: 'meters' });
        
        if (distance <= searchRadius) {
          nearbyFeatures.push({
            featureId: feature.id || feature.properties?.id,
            name: feature.properties?.name || layerName,
            distance: Math.round(distance),
            coordinates: feature.geometry.coordinates,
            bearing: this.calculateBearing(centroid.geometry.coordinates, feature.geometry.coordinates)
          });
        }
      }
      
      if (nearbyFeatures.length > 0) {
        // Sort by distance
        nearbyFeatures.sort((a, b) => a.distance - b.distance);
        proximities[layerName] = nearbyFeatures.slice(0, 5); // Top 5 closest
      }
    }
    
    return proximities;
  }

  async analyzeAccessibility(siteGeometry, siteAddress) {
    const centroid = turf.centroid(siteGeometry);
    const accessibility = {
      publicTransportAccessibilityLevel: null,
      walkingDistanceToStations: [],
      cyclingInfrastructure: null,
      roadNetworkAccess: null
    };

    // PTAL calculation (simplified)
    const ptal = await this.calculatePTAL(centroid);
    accessibility.publicTransportAccessibilityLevel = ptal;

    // Walking distances to transport
    const stations = this.constraintLayers.get('railwayStations')?.features || [];
    for (const station of stations.slice(0, 3)) { // Top 3 closest
      const walkingDistance = turf.distance(centroid, station, { units: 'meters' });
      if (walkingDistance <= 2000) { // Within 2km
        accessibility.walkingDistanceToStations.push({
          name: station.properties?.name,
          distance: Math.round(walkingDistance),
          walkingTime: Math.round(walkingDistance / 1.4 / 60) // Assume 1.4 m/s walking speed
        });
      }
    }

    return accessibility;
  }

  async analyzeContext(siteGeometry, siteAddress) {
    const context = {
      landUsePattern: null,
      buildingDensity: null,
      streetPattern: null,
      characterAssessment: null
    };

    // Use Google Street View API if available and address provided
    if (this.googleMapsApiKey && siteAddress) {
      try {
        context.streetViewAnalysis = await this.getStreetViewContext(siteAddress);
      } catch (error) {
        console.warn('Street View analysis failed:', error);
      }
    }

    return context;
  }

  generateAnalysisEvidence(analysis) {
    const evidence = [];
    
    // Site metrics evidence
    if (analysis.siteMetrics && analysis.siteMetrics.area) {
      evidence.push({
        type: 'spatial',
        category: 'site_metrics',
        description: `Site area: ${analysis.siteMetrics.area}m (${(analysis.siteMetrics.area / 10000).toFixed(2)} hectares)`,
        confidence: 1.0,
        source: 'calculated'
      });
    }

    if (analysis.siteMetrics.frontageLength) {
      evidence.push({
        type: 'spatial',
        category: 'site_metrics',
        description: `Primary frontage length: ${analysis.siteMetrics.frontageLength}m`,
        confidence: 0.8,
        source: 'calculated'
      });
    }

    // Intersection evidence
    for (const [layerName, intersections] of Object.entries(analysis.intersections)) {
      for (const intersection of intersections) {
        if (intersection.coveragePercent) {
          evidence.push({
            type: 'spatial',
            category: 'constraints',
            description: `Site overlaps ${layerName.replace(/([A-Z])/g, ' $1').toLowerCase()} by ${intersection.coveragePercent}% (${intersection.area}m)`,
            confidence: 0.95,
            source: 'spatial_analysis',
            constraint: layerName,
            impact: intersection.coveragePercent > 50 ? 'high' : intersection.coveragePercent > 20 ? 'medium' : 'low'
          });
        } else if (intersection.withinSite) {
          evidence.push({
            type: 'spatial',
            category: 'constraints',
            description: `${intersection.name} located within site boundary`,
            confidence: 1.0,
            source: 'spatial_analysis',
            constraint: layerName,
            impact: 'high'
          });
        }
      }
    }

    // Proximity evidence
    for (const [layerName, proximities] of Object.entries(analysis.proximities)) {
      const closest = proximities[0];
      if (closest) {
        let description = `${closest.distance}m to nearest ${layerName.replace(/([A-Z])/g, ' $1').toLowerCase()}`;
        if (closest.name) {
          description += ` (${closest.name})`;
        }
        
        evidence.push({
          type: 'spatial',
          category: 'accessibility',
          description: description,
          confidence: 0.9,
          source: 'spatial_analysis',
          distance: closest.distance,
          feature: layerName
        });
      }
    }

    // Accessibility evidence
    if (analysis.accessibilityAnalysis.publicTransportAccessibilityLevel) {
      evidence.push({
        type: 'spatial',
        category: 'accessibility',
        description: `Public Transport Accessibility Level: ${analysis.accessibilityAnalysis.publicTransportAccessibilityLevel}`,
        confidence: 0.8,
        source: 'calculated',
        ptal: analysis.accessibilityAnalysis.publicTransportAccessibilityLevel
      });
    }

    return context;
  }

  // Helper methods
  calculatePerimeter(geometry) {
    if (geometry.type === 'Polygon') {
      return turf.length(turf.polygonToLine(geometry), { units: 'meters' });
    }
    return 0;
  }

  async calculateFrontageLength(geometry) {
    // Simplified: assume longest edge is primary frontage
    if (geometry.type === 'Polygon') {
      const coordinates = geometry.coordinates[0];
      let maxDistance = 0;
      
      for (let i = 0; i < coordinates.length - 1; i++) {
        const distance = turf.distance(coordinates[i], coordinates[i + 1], { units: 'meters' });
        maxDistance = Math.max(maxDistance, distance);
      }
      
      return maxDistance;
    }
    return 0;
  }

  async estimatePlotRatio(geometry) {
    // Placeholder - would need building footprint data
    return null;
  }

  calculateAspectRatio(bbox) {
    const width = bbox[2] - bbox[0];
    const height = bbox[3] - bbox[1];
    return Math.round((width / height) * 100) / 100;
  }

  calculateBearing(from, to) {
    return Math.round(turf.bearing(from, to));
  }

  async calculatePTAL(centroid) {
    // Simplified PTAL calculation
    // In reality, this would need detailed transport timetable data
    const stations = this.constraintLayers.get('railwayStations')?.features || [];
    const busStops = this.constraintLayers.get('busStops')?.features || [];
    
    let score = 0;
    
    // Railway stations within walking distance
    for (const station of stations) {
      const distance = turf.distance(centroid, station, { units: 'meters' });
      if (distance <= 960) score += 4; // High frequency
      else if (distance <= 1280) score += 3; // Medium frequency
      else if (distance <= 1600) score += 2; // Low frequency
    }
    
    // Bus stops within walking distance
    let busScore = 0;
    for (const stop of busStops) {
      const distance = turf.distance(centroid, stop, { units: 'meters' });
      if (distance <= 320) busScore += 2;
      else if (distance <= 640) busScore += 1;
    }
    
    score += Math.min(busScore, 6); // Cap bus contribution
    
    // Convert to PTAL band
    if (score >= 25) return '6a';
    if (score >= 20) return '5';
    if (score >= 15) return '4';
    if (score >= 10) return '3';
    if (score >= 5) return '2';
    if (score >= 2.5) return '1b';
    if (score >= 0) return '1a';
    return '0';
  }

  async getStreetViewContext(address) {
    if (!this.googleMapsApiKey) return null;
    
    // This would call Google Street View Static API
    // For now, return placeholder
    return {
      available: false,
      reason: 'Implementation pending'
    };
  }

  /**
   * Query specific constraint types for given coordinates
   */
  async queryConstraints(coordinates, constraintTypes = []) {
    if (!coordinates || coordinates.length < 2) {
      throw new Error('Valid coordinates required for constraint query');
    }

    const [longitude, latitude] = coordinates;
    const results = [];

    try {
      // Initialize if not already done
      if (!this.initialized) {
        await this.initialize();
      }

      // Create point geometry for intersection queries
      const point = turf.point([longitude, latitude]);
      
      // Query each requested constraint type
      for (const constraintType of constraintTypes) {
        try {
          const constraintData = await this.queryConstraintType(point, constraintType);
          if (constraintData && constraintData.length > 0) {
            results.push({
              type: constraintType,
              constraints: constraintData,
              count: constraintData.length
            });
          }
        } catch (error) {
          console.warn(`Failed to query constraint type ${constraintType}:`, error.message);
        }
      }

      return results;
    } catch (error) {
      console.error('Constraint query failed:', error);
      throw error;
    }
  }

  /**
   * Query a specific constraint type
   */
  async queryConstraintType(point, constraintType) {
    const constraintMapping = {
      'conservationAreas': ['conservation-area'],
      'listedBuildings': ['listed-building-outline'],
      'floodZones': ['flood-map-for-planning-rivers-and-sea-flood-zone-2', 'flood-map-for-planning-rivers-and-sea-flood-zone-3'],
      'greenBelt': ['green-belt'],
      'treePreservationOrders': ['tree-preservation-order'],
      'scheduledMonuments': ['scheduled-monument']
    };

    const datasetNames = constraintMapping[constraintType] || [constraintType];
    const results = [];

    // Ensure datasets are available
    if (!this.datasets || !Array.isArray(this.datasets)) {
      console.warn(`Datasets not initialized for constraint type ${constraintType}`);
      return results;
    }

    for (const datasetName of datasetNames) {
      const dataset = this.datasets.find(d => d.dataset === datasetName);
      if (dataset && dataset.endpoint) {
        try {
          const intersectionResult = await this.checkIntersection(point, dataset);
          if (intersectionResult.intersects) {
            results.push({
              dataset: datasetName,
              name: dataset.name || datasetName,
              intersects: true,
              coverage: intersectionResult.coverage || 100,
              properties: intersectionResult.properties || {}
            });
          }
        } catch (error) {
          console.warn(`Failed to check intersection for ${datasetName}:`, error.message);
        }
      }
    }

    return results;
  }

  /**
   * Helper method to try multiple dataset names for transport data
   */
  async getTransportData(latitude, longitude, datasetNames, limit, type) {
    // For now, skip transport API calls due to dataset availability issues
    // Return empty array to allow assessment to continue
    console.log(`Skipping ${type} data collection - datasets not available in planning.data.gov.uk`);
    console.log(`Attempted datasets: ${datasetNames.join(', ')}`);
    console.log(`Manual transport assessment recommended for coordinates: ${latitude}, ${longitude}`);
    return [];
    
    /* Original implementation - commented out due to 422 errors
    for (const datasetName of datasetNames) {
      try {
        const results = await this.planningDataAPI.searchByLocation(latitude, longitude, [datasetName], limit);
        if (results && results.length > 0) {
          console.log(`Successfully found ${type} using dataset: ${datasetName}`);
          return results;
        }
      } catch (error) {
        if (error.message.includes('422')) {
          console.warn(`Dataset ${datasetName} not available (422 error) - trying alternative`);
        } else {
          console.warn(`Failed to fetch ${type} with dataset ${datasetName}:`, error.message);
        }
      }
    }
    
    console.warn(`No ${type} data found for any of the attempted datasets:`, datasetNames);
    console.log(`This may be normal if the area doesn't have ${type} or if dataset names have changed`);
    return [];
    */
  }
}
